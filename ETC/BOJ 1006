#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    int t;
    cin>>t;
    for(int i=0; i<t; i++)
    {
        int n,w;
        cin>>n>>w;
        int map[2][n],dp[4][5][n],link[n][3],high[4][n];//map=구역입력값,dp=4가지경우마다개수,link=n과n-1사이에서 연결유형, high=큰거
        fill(link[0],link[0]+n*3,0);
        fill(&dp[0][0][0], &dp[4][0][0], 0);
        for(int z=0; z<2; z++)//1.입력받기
        {
            for(int x=0; x<n; x++)
                cin>>map[z][x];
        }
        for(int z=0; z<n; z++)//2.연결가능한거 계산
        {
            if(z==0)
            {
                if(map[0][z]+map[0][n-1]<=w)
                    link[z][0]=1;
                if(map[1][z]+map[1][n-1]<=w)
                    link[z][1]=1;
                if(map[0][z]+map[1][z]<=w)
                    link[z][2]=1;                
            }
            else
            {
                if(map[0][z]+map[0][z-1]<=w)//위쪽가로
                    link[z][0]=1;
                if(map[1][z]+map[1][z-1]<=w)//아래쪽가로
                    link[z][1]=1;
                if(map[0][z]+map[1][z]<=w)//세로
                    link[z][2]=1;
            }
        }
        for(int z=0; z<n; z++)//3.계산 dp배열 dp[4][5][n],link[n][3]
        {
            if(z==0)//처음
            {
                if(link[0][0]&&link[0][1])
                {
                    dp[2][2][0]=2;
                    high[2][z]=2;
                }
                else if(link[0][0])
                {
                    dp[0][0][0]=1;
                    high[0][z]=1;
                }
                else if(link[0][1])
                {
                    dp[1][1][0]=1;
                    high[1][z]=1;
                }
                else if(link[0][2])
                {
                    dp[3][3][0]=1;
                    high[3][z]=1;
                }
            }
            else if(z==n-1)//마지막
            {
                
            }
            else//중간
            {
                for(int x=0; x<4; x++)//나머지 경우
                {
                    for(int c=0; c<5; c++)
                        dp[x][c][z]=high[x][z-1];
                }
                if(link[z][0]&&link[z][1])//2
                {
                    dp[0][2][z]=dp[0][4][z-1]+2;
                    dp[1][2][z]=dp[1][4][z-1]+2;
                    dp[2][2][z]=dp[2][4][z-1]+2;
                    dp[3][2][z]=dp[3][4][z-1]+2;
                }
                if(link[z][0])//0
                {
                    dp[0][0][z]=max(dp[0][1][z-1],dp[0][4][z-1])+1;
                    dp[1][0][z]=max(dp[1][1][z-1],dp[1][4][z-1])+1;
                    dp[2][0][z]=max(dp[2][1][z-1],dp[2][4][z-1])+1;
                    dp[3][0][z]=max(dp[3][1][z-1],dp[3][4][z-1])+1;
                }
                if(link[z][1])//1
                {
                    dp[0][1][z]=max(dp[0][0][z-1],dp[0][4][z-1])+1;
                    dp[1][1][z]=max(dp[1][0][z-1],dp[1][4][z-1])+1;
                    dp[2][1][z]=max(dp[2][0][z-1],dp[2][4][z-1])+1;
                    dp[3][1][z]=max(dp[3][0][z-1],dp[3][4][z-1])+1;
                }
                if(link[z][2])//3
                {
                    dp[0][3][z]=max(max(max(dp[0][0][z-1],dp[0][1][z-1]),max(dp[0][2][z-1],dp[0][3][z-1])),dp[0][4][z-1])+1;
                    dp[1][3][z]=max(max(max(dp[1][0][z-1],dp[1][1][z-1]),max(dp[1][2][z-1],dp[1][3][z-1])),dp[1][4][z-1])+1;
                    dp[2][3][z]=max(max(max(dp[2][0][z-1],dp[2][1][z-1]),max(dp[2][2][z-1],dp[2][3][z-1])),dp[2][4][z-1])+1;
                    dp[3][3][z]=max(max(max(dp[3][0][z-1],dp[3][1][z-1]),max(dp[3][2][z-1],dp[3][3][z-1])),dp[3][4][z-1])+1;  
                }
                for(int x=0; x<4; x++)//high값 구하기
                    high[x][z]=max(max(max(dp[x][0][z],dp[x][1][z]),max(dp[x][2][z],dp[x][3][z])),dp[x][4][z]);
            }
        }
        for(int z=0; z<4; z++)
        {
            for(int x=0; x<5; x++)
            {
                for(int c=0; c<n; c++)
                    cout<<dp[z][x][c]<<' ';
                cout<<'\n';
            }
            cout<<'\n';
        }
    }
}
