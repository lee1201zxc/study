#include<iostream>
using namespace std;
int main()
{
    int t;
    cin>>t;
    for(int i=0; i<t; i++)
    {
        int n,s,e;
        cin>>n>>s>>e;
        if((s==1&&e==n)||(s==n&&e==1))
            cout<<0<<'\n';
        else if(e==n||e==1)
        {
            if(e-s==1||e-s==-1)
                cout<<1<<'\n';
            else
                cout<<2<<'\n';
        }
        else if(s==1||s==n)
            cout<<1<<'\n';
        else
        {
            if(s-e==1||s-e==-1)
                cout<<1<<'\n';
            else
                cout<<2<<'\n';
        }
    }
}
/*
조건을 여러개 설정하는 문제이다.
S에서 출발해 모든 지점을 지난다음 E에 도착해야 한다. 이를 최소 경우의 수로 가야한다.
최소 경우의 수로 가려면 시작지점에서 한쪽으로 쭉 간다음 1이나n으로 순간이동해서 다시 쭉가는 과정을 반복해야 한다.
순간이동할 때 비용이 1드는데 1,n두군데 뿐이므로 비용은 최대 2이다.

아래는 분기를 정리해놓은 곳이다.
1. S,E둘다 끝에 있는 경우(1,n) -> 0번
2. E하나만 끝에 있는 경우(1,n)
  2.1 S,E의 방위치가 하나 차이나는 경우 -> 1번
  2.2 S,E의 방위치가 둘이상 차이나는 경우 -> 2번
3. S하나만 끝에 있는 경우(1,n) -> 1번
4. S,E의 방위치가 하나 차이나는 경우 -> 1번
5. S,E의 방위치가 둘이상 차이나는 경우 -> 2번
이 경우를 모두 구현해주면 된다.
문제는 쉬워보이나 위와 같은 예외 조건을 찾는 것이 생각보다 시간이 많이 걸렸다.

*/
