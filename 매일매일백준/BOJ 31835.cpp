#include<iostream>
using namespace std;
int main(void)
{
	int n;
	cin>>n;
	char s[n],a;
	for(int i=0; i<n; i++)
	{
		cin>>s[i];
	}
	for(int i=0; i<n-4; i+=2)
	{
		if(s[i+1]=='&')
		{
			if(s[i]=='T'&&s[i+2]=='T')
				s[i+2]='T';
			else
				s[i+2]='F';
		}
		else
		{
			if(s[i]=='T'||s[i+2]=='T')
				s[i+2]='T';
			else
				s[i+2]='F';
		}
	}
	cin>>a;
	if(n==1)
	{
		if(s[0]==a)
			cout<<0;
		else
			cout<<1;
	}
	else
	{
		if(s[n-2]=='|')
		{
			if(s[n-1]=='T'&&s[n-3]=='T')
			{
				if(s[n-1]==a)
					cout<<0;
				else
					cout<<2;
			}
			else if(s[n-1]=='F'&&s[n-3]=='F')
			{
				if(s[n-1]==a)
					cout<<0;
				else
					cout<<1;
			}
			else
			{
				if(a=='T')
					cout<<0;
				else
					cout<<1;
			}
		}
		else
		{
			if(s[n-1]=='T'&&s[n-3]=='T')
			{
				if(s[n-1]==a)
					cout<<0;
				else
					cout<<1;
			}
			else if(s[n-1]=='F'&&s[n-3]=='F')
			{
				if(s[n-1]==a)
					cout<<0;
				else
					cout<<2;
			}
			else
			{
				if(a=='T')
					cout<<1;
				else
					cout<<0;
			}
		}
	}
}
/*
값이나 연산자를 변경하여 올바른 값이 나오도록 하는 문제이다.
일단 가장 먼저 생각한 것이 앞에서 부터 순서대로 계산되므로 일단 계산한다음 가장 마지막 연산을 할 때 값과 연산자를 바꿔도 되지않을까? 라는 생각을 하였다.
아래 표는 마지막 연산이 다음과 같고 최종 연산값인 C가 다음과 같을 때 값,연산자를 몇번 바꿔야 올바른 식이 되는지 나타내는 표이다.
    c ->  T   F
T | T ->  0   2
T & T ->  0   1
T | F ->  0   1
F | T ->  0   1
T & F ->  1   0
F & T ->  1   0
F | F ->  1   0
F & F ->  2   0
아무리 최악이어도 2번안에는 만들어진다.
그런데 만약에 앞 연산은 그냥 계산하고 맨 뒤의 연산에서 값,연산자를 바꾸는 방법이 잘못됬다면??
그럴리는 없다. 성립하려면 앞에서 값을 바꾸는 방법이 바꾸는 횟수가 더 적어야 하는데 
예를 들어 마지막 연산이 T | T 이고 이 결과가 F 가 나오게 하려면 2번 바꿔야 한다.ex(F|F or T&F)
앞에서 한번 바꿔서 마지막 연산이 F|T가 되었다고 하자 이 결과가 F가 나오게 하려면 한 번을 바꿔야 한다.
즉 총 2번 이므로 마지막에 모두 바꿔주는 것이랑 같다.
결론은 앞 연산은 그대로 계산하되 맨 마지막 연산에서 값을 바꿔줘도 아무런 문제가 없다는 뜻이다.
그래서 위에서 구한 표를 가지고 코드를 작성해주면 된다.
*/
