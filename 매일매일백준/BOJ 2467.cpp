#include<iostream>
using namespace std;
int main(void)
{
    int n,k=2000000000;
    cin>>n;
    int a[n],b[2];
    for(int i=0; i<n; i++)
        cin>>a[i];
        
    int i=0,j=n-1;
    while(i<j)
    {
        int q=a[i]+a[j],w;
        w=q>0?q:q*-1;
        if(w<k)
        {
            k=w;
            b[0]=a[i],b[1]=a[j];
        }
        if(q<0)
            i++;
        else
            j--;
    }
    cout<<b[0]<<' '<<b[1];
}
/*
숫자는 정렬되어 있다. 정렬되어 있고, 특정값에 최대한 가깝게 구하는 문제라면 투포인터 기법을 이용할 수 있다.
가장 큰 수와 가장 작은 수를 더한 후 만약 특정값보다 크다면 가장 큰 수 대신에 가장 큰 수 다음으로 작은 수를 더하고,
특정값보다 작다면 가장 작은 수 대신 다음으로 작은 수를 더한다... 이를 끝까지 반복하면 결국에는 특정값에 가장 가까운 두 수의 합을
구할 수 있다. 수들이 정렬되있고, 특정값에 가까운 수를 구하기 이 두가지 조건을 보면 무조건 투 포인터를 이용한다고 생각하면 된다.
이 기법 없이 문제를 구하려면 모든 경우의 수를 탐색해야 해서 n^2이 나오게 되는데 투 포인터 기법을 이용하면 O(n)만에 된다!
매우 빠른 속도로 구할 수 있으나 경우가 한정적인 단점이 있다.
*/
